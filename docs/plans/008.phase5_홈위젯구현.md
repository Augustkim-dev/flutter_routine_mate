# 008. Phase 5: 홈 위젯 구현 (Post-MVP)

## 📋 작업 개요
**목표**: iOS/Android 네이티브 홈 위젯 구현 및 앱과의 동기화
**예상 기간**: 3일
**우선순위**: P1 (Post-MVP)

## 🎯 작업 목표
1. iOS 위젯 구현 (WidgetKit)
2. Android 위젯 구현 (AppWidget)
3. Flutter MethodChannel 설정
4. 위젯-앱 간 데이터 동기화
5. 위젯 설정 화면 구현

## 📂 생성할 파일 구조
```
# Flutter 측
lib/
└── features/
    └── widget/
        ├── data/
        │   ├── services/
        │   │   └── widget_service.dart
        │   └── models/
        │       └── widget_data_model.dart
        ├── domain/
        │   └── usecases/
        │       ├── update_widget_usecase.dart
        │       └── sync_widget_data_usecase.dart
        └── presentation/
            ├── screens/
            │   └── widget_settings_screen.dart
            └── widgets/
                └── widget_routine_selector.dart

# iOS 측
ios/
└── RoutineWidget/
    ├── RoutineWidget.swift
    ├── RoutineWidgetBundle.swift
    ├── Provider/
    │   └── RoutineProvider.swift
    ├── Views/
    │   ├── SmallWidgetView.swift
    │   ├── MediumWidgetView.swift
    │   └── LargeWidgetView.swift
    ├── Models/
    │   └── RoutineEntry.swift
    └── Intents/
        └── ConfigurationIntent.swift

# Android 측
android/app/src/main/
├── java/com/routinemate/app/
│   └── widget/
│       ├── RoutineWidgetProvider.kt
│       ├── RoutineWidgetService.kt
│       └── RoutineWidgetConfigActivity.kt
└── res/
    ├── layout/
    │   ├── widget_routine_small.xml
    │   ├── widget_routine_medium.xml
    │   └── widget_routine_large.xml
    └── xml/
        └── routine_widget_info.xml
```

## 🔧 상세 구현 계획

### 1. Flutter MethodChannel 설정
```dart
// widget_service.dart
class WidgetService {
  static const platform = MethodChannel('com.routinemate.app/widget');

  // 위젯으로 데이터 전송
  static Future<void> updateWidget(String routineId) async {
    try {
      final routine = await _getRoutine(routineId);
      await platform.invokeMethod('updateWidget', {
        'routineId': routine.id,
        'name': routine.name,
        'iconIndex': routine.iconIndex,
        'colorIndex': routine.colorIndex,
        'isCompleted': routine.isCompletedToday,
        'streak': routine.currentStreak,
      });
    } on PlatformException catch (e) {
      debugPrint("Failed to update widget: ${e.message}");
    }
  }

  // 위젯에서 액션 수신
  static void setupMethodCallHandler() {
    platform.setMethodCallHandler((call) async {
      switch (call.method) {
        case 'toggleFromWidget':
          final routineId = call.arguments['routineId'] as String;
          await _toggleRoutineFromWidget(routineId);
          break;
        case 'openRoutine':
          final routineId = call.arguments['routineId'] as String;
          _navigateToRoutine(routineId);
          break;
      }
    });
  }

  // 모든 위젯 업데이트
  static Future<void> updateAllWidgets() async {
    final settings = await _getWidgetSettings();
    final routines = await _getRoutines(settings.selectedRoutineIds);

    await platform.invokeMethod('updateAllWidgets', {
      'routines': routines.map((r) => r.toWidgetData()).toList(),
    });
  }
}
```

### 2. iOS 위젯 구현 (SwiftUI + WidgetKit)

#### 2.1 Widget Entry
```swift
// RoutineEntry.swift
struct RoutineEntry: TimelineEntry {
    let date: Date
    let routines: [RoutineData]
    let configuration: ConfigurationIntent
}

struct RoutineData: Codable {
    let id: String
    let name: String
    let iconIndex: Int
    let colorIndex: Int
    let isCompleted: Bool
    let streak: Int
}
```

#### 2.2 Widget Views
```swift
// SmallWidgetView.swift (1x1)
struct SmallWidgetView: View {
    let routine: RoutineData

    var body: some View {
        Link(destination: URL(string: "routinemate://toggle/\(routine.id)")!) {
            VStack(spacing: 8) {
                Image(systemName: getIcon(routine.iconIndex))
                    .font(.system(size: 24))
                    .foregroundColor(getColor(routine.colorIndex))

                Text(routine.name)
                    .font(.caption)
                    .lineLimit(2)

                Image(systemName: routine.isCompleted ? "checkmark.circle.fill" : "circle")
                    .font(.system(size: 20))
                    .foregroundColor(routine.isCompleted ? .green : .gray)
            }
            .padding()
            .background(ContainerRelativeShape().fill(Color(.systemBackground)))
        }
    }
}

// MediumWidgetView.swift (2x2)
struct MediumWidgetView: View {
    let routines: [RoutineData]

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("오늘의 루틴")
                .font(.headline)

            ForEach(routines.prefix(3)) { routine in
                Link(destination: URL(string: "routinemate://toggle/\(routine.id)")!) {
                    HStack {
                        Image(systemName: getIcon(routine.iconIndex))
                        Text(routine.name)
                        Spacer()
                        Image(systemName: routine.isCompleted ? "checkmark.circle.fill" : "circle")
                    }
                }
            }

            Text("\(completedCount)/\(totalCount) 완료")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding()
    }
}
```

#### 2.3 Timeline Provider
```swift
// RoutineProvider.swift
struct RoutineProvider: IntentTimelineProvider {
    func getTimeline(for configuration: ConfigurationIntent,
                    in context: Context,
                    completion: @escaping (Timeline<RoutineEntry>) -> ()) {

        let routines = loadRoutinesFromSharedContainer()
        let entry = RoutineEntry(date: Date(), routines: routines, configuration: configuration)

        // 자정에 리프레시
        let midnight = Calendar.current.startOfDay(for: Date()).addingTimeInterval(86400)
        let timeline = Timeline(entries: [entry], policy: .after(midnight))

        completion(timeline)
    }
}
```

### 3. Android 위젯 구현

#### 3.1 Widget Provider
```kotlin
// RoutineWidgetProvider.kt
class RoutineWidgetProvider : AppWidgetProvider() {

    override fun onUpdate(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetIds: IntArray
    ) {
        for (appWidgetId in appWidgetIds) {
            updateAppWidget(context, appWidgetManager, appWidgetId)
        }
    }

    private fun updateAppWidget(
        context: Context,
        appWidgetManager: AppWidgetManager,
        appWidgetId: Int
    ) {
        val routines = loadRoutinesFromSharedPrefs(context)
        val views = getRemoteViews(context, routines)

        // 클릭 이벤트 설정
        routines.forEachIndexed { index, routine ->
            val intent = Intent(context, RoutineWidgetProvider::class.java).apply {
                action = ACTION_TOGGLE_ROUTINE
                putExtra(EXTRA_ROUTINE_ID, routine.id)
            }
            val pendingIntent = PendingIntent.getBroadcast(
                context,
                routine.id.hashCode(),
                intent,
                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
            )
            views.setOnClickPendingIntent(getViewId(index), pendingIntent)
        }

        appWidgetManager.updateAppWidget(appWidgetId, views)
    }

    override fun onReceive(context: Context, intent: Intent) {
        super.onReceive(context, intent)

        if (intent.action == ACTION_TOGGLE_ROUTINE) {
            val routineId = intent.getStringExtra(EXTRA_ROUTINE_ID)
            // Flutter로 전달
            MainActivity.methodChannel?.invokeMethod(
                "toggleFromWidget",
                mapOf("routineId" to routineId)
            )
            // 위젯 업데이트
            updateAllWidgets(context)
        }
    }
}
```

#### 3.2 Widget Layout
```xml
<!-- widget_routine_medium.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="vertical"
    android:padding="16dp"
    android:background="@drawable/widget_background">

    <TextView
        android:id="@+id/widget_title"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="오늘의 루틴"
        android:textSize="16sp"
        android:textStyle="bold"/>

    <LinearLayout
        android:id="@+id/routines_container"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="vertical"
        android:layout_marginTop="8dp">

        <!-- 동적으로 루틴 항목 추가 -->

    </LinearLayout>

    <TextView
        android:id="@+id/completion_text"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:text="0/0 완료"
        android:textSize="12sp"
        android:layout_marginTop="8dp"/>

</LinearLayout>
```

### 4. 위젯 설정 화면
```dart
// widget_settings_screen.dart
class WidgetSettingsScreen extends ConsumerStatefulWidget {
  @override
  _WidgetSettingsScreenState createState() => _WidgetSettingsScreenState();
}

class _WidgetSettingsScreenState extends ConsumerState<WidgetSettingsScreen> {
  List<String> selectedRoutineIds = [];

  @override
  Widget build(BuildContext context) {
    final routines = ref.watch(routineListProvider);

    return Scaffold(
      appBar: AppBar(
        title: Text('위젯 설정'),
        actions: [
          TextButton(
            onPressed: _saveSettings,
            child: Text('저장'),
          ),
        ],
      ),
      body: Column(
        children: [
          Padding(
            padding: EdgeInsets.all(16),
            child: Text(
              '홈 화면 위젯에 표시할 루틴을 선택하세요 (최대 6개)',
              style: Theme.of(context).textTheme.bodyMedium,
            ),
          ),
          Expanded(
            child: routines.when(
              data: (list) => ListView.builder(
                itemCount: list.length,
                itemBuilder: (context, index) {
                  final routine = list[index];
                  final isSelected = selectedRoutineIds.contains(routine.id);

                  return CheckboxListTile(
                    title: Text(routine.name),
                    value: isSelected,
                    onChanged: selectedRoutineIds.length < 6 || isSelected
                        ? (value) => _toggleSelection(routine.id)
                        : null,
                    secondary: Icon(
                      getIconData(routine.iconIndex),
                      color: getColor(routine.colorIndex),
                    ),
                  );
                },
              ),
              loading: () => CircularProgressIndicator(),
              error: (error, stack) => Text('오류 발생'),
            ),
          ),
        ],
      ),
    );
  }

  void _toggleSelection(String routineId) {
    setState(() {
      if (selectedRoutineIds.contains(routineId)) {
        selectedRoutineIds.remove(routineId);
      } else {
        selectedRoutineIds.add(routineId);
      }
    });
  }

  Future<void> _saveSettings() async {
    await WidgetService.saveWidgetSettings(selectedRoutineIds);
    await WidgetService.updateAllWidgets();
    Navigator.pop(context);
  }
}
```

### 5. 자동 업데이트 로직
```dart
// 앱에서 루틴 체크 시
Future<void> toggleRoutineCompletion(String routineId) async {
  // DB 업데이트
  await repository.toggleCompletion(routineId);

  // 위젯 업데이트
  await WidgetService.updateWidget(routineId);
}

// 자정 리셋
void scheduleWidgetReset() {
  final now = DateTime.now();
  final midnight = DateTime(now.year, now.month, now.day + 1);
  final duration = midnight.difference(now);

  Timer(duration, () async {
    await WidgetService.resetAllWidgets();
    scheduleWidgetReset(); // 다음 자정 예약
  });
}
```

## 🧪 테스트 계획
1. **위젯 렌더링 테스트**
   - 각 크기별 레이아웃 확인
   - 다크모드 지원
   - 다양한 화면 밀도

2. **동기화 테스트**
   - 앱 → 위젯 업데이트
   - 위젯 → 앱 액션
   - 오프라인 상태 처리

3. **성능 테스트**
   - 위젯 업데이트 속도
   - 배터리 사용량
   - 메모리 사용량

## ⚠️ 주의사항
1. **iOS 제약사항**
   - WidgetKit은 iOS 14+ 필요
   - 위젯 업데이트 제한 (일일 최대 횟수)
   - 백그라운드 처리 제한

2. **Android 제약사항**
   - 다양한 런처 호환성
   - 위젯 크기 유연성
   - 업데이트 빈도 제한

3. **데이터 동기화**
   - App Group (iOS) / SharedPreferences (Android) 사용
   - 데이터 크기 제한
   - 보안 고려사항

## 🎯 완료 기준
- [ ] iOS 위젯 3가지 크기 구현
- [ ] Android 위젯 3가지 크기 구현
- [ ] 위젯-앱 양방향 통신
- [ ] 위젯 설정 화면 구현
- [ ] 자동 업데이트 및 자정 리셋

## 📝 다음 단계
Phase 6: 알림 시스템 구현으로 진행