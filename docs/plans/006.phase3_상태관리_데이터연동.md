# 006. Phase 3: 상태 관리 및 데이터 연동

## 📋 작업 개요
**목표**: Riverpod을 활용한 상태 관리 시스템 구축 및 UI-데이터 연동
**예상 기간**: 2일
**우선순위**: P0 (필수)

## 🎯 작업 목표
1. Riverpod Provider 아키텍처 구축
2. 상태 관리 로직 구현
3. UI와 Repository 연결
4. 실시간 데이터 동기화
5. 에러 처리 및 로딩 상태 관리

## 📂 생성할 파일 구조
```
lib/
├── core/
│   └── providers/
│       ├── database_provider.dart
│       └── shared_preferences_provider.dart
└── features/
    └── routine/
        └── presentation/
            ├── providers/
            │   ├── routine_list_provider.dart
            │   ├── routine_form_provider.dart
            │   ├── filter_provider.dart
            │   ├── sort_provider.dart
            │   ├── completion_stats_provider.dart
            │   └── selected_routine_provider.dart
            ├── notifiers/
            │   ├── routine_list_notifier.dart
            │   ├── routine_form_notifier.dart
            │   └── completion_notifier.dart
            └── states/
                ├── routine_list_state.dart
                ├── routine_form_state.dart
                └── filter_state.dart
```

## 🔧 상세 구현 계획

### 1. Provider 구조
```dart
// database_provider.dart
final databaseProvider = Provider<DatabaseHelper>((ref) {
  return DatabaseHelper();
});

// routine_repository_provider.dart
final routineRepositoryProvider = Provider<RoutineRepository>((ref) {
  final database = ref.watch(databaseProvider);
  return RoutineRepositoryImpl(database);
});
```

### 2. 루틴 리스트 상태 관리
```dart
// routine_list_state.dart
@freezed
class RoutineListState with _$RoutineListState {
  const factory RoutineListState({
    @Default([]) List<Routine> routines,
    @Default(false) bool isLoading,
    @Default(null) String? errorMessage,
    @Default(FilterType.all) FilterType filter,
    @Default(SortType.created) SortType sort,
  }) = _RoutineListState;
}

// routine_list_notifier.dart
class RoutineListNotifier extends StateNotifier<AsyncValue<List<Routine>>> {
  final RoutineRepository _repository;

  Future<void> loadRoutines() async {...}
  Future<void> addRoutine(Routine routine) async {...}
  Future<void> updateRoutine(Routine routine) async {...}
  Future<void> deleteRoutine(String id) async {...}
  Future<void> toggleCompletion(String id) async {...}
}

// routine_list_provider.dart
final routineListProvider = StateNotifierProvider<
  RoutineListNotifier,
  AsyncValue<List<Routine>>
>((ref) {
  final repository = ref.watch(routineRepositoryProvider);
  return RoutineListNotifier(repository);
});
```

### 3. 필터/정렬 Provider
```dart
// filter_provider.dart
enum FilterType { all, today, completed, incomplete }

final filterProvider = StateProvider<FilterType>((ref) => FilterType.all);

// sort_provider.dart
enum SortType { created, name, color, completion, custom }

final sortProvider = StateProvider<SortType>((ref) => SortType.created);

// filtered_routines_provider.dart
final filteredRoutinesProvider = Provider<AsyncValue<List<Routine>>>((ref) {
  final routines = ref.watch(routineListProvider);
  final filter = ref.watch(filterProvider);
  final sort = ref.watch(sortProvider);

  return routines.whenData((list) {
    var filtered = _applyFilter(list, filter);
    var sorted = _applySort(filtered, sort);
    return sorted;
  });
});
```

### 4. 완료 통계 Provider
```dart
// completion_stats_provider.dart
@freezed
class CompletionStats with _$CompletionStats {
  const factory CompletionStats({
    required int total,
    required int completed,
    required double percentage,
    required Map<String, int> streaks,
  }) = _CompletionStats;
}

final todayCompletionProvider = Provider<AsyncValue<CompletionStats>>((ref) {
  final routines = ref.watch(filteredRoutinesProvider);

  return routines.whenData((list) {
    final today = list.where((r) => r.isScheduledToday);
    final completed = today.where((r) => r.isCompletedToday);

    return CompletionStats(
      total: today.length,
      completed: completed.length,
      percentage: today.isEmpty ? 0 : (completed.length / today.length * 100),
      streaks: _calculateStreaks(list),
    );
  });
});
```

### 5. 폼 상태 관리
```dart
// routine_form_state.dart
@freezed
class RoutineFormState with _$RoutineFormState {
  const factory RoutineFormState({
    @Default('') String name,
    @Default(0) int iconIndex,
    @Default(0) int colorIndex,
    @Default(ScheduleType.daily) ScheduleType scheduleType,
    @Default([]) List<int> customDays,
    @Default(false) bool isValid,
    @Default(null) String? errorMessage,
  }) = _RoutineFormState;
}

// routine_form_notifier.dart
class RoutineFormNotifier extends StateNotifier<RoutineFormState> {
  void updateName(String name) {...}
  void updateIcon(int index) {...}
  void updateColor(int index) {...}
  void updateSchedule(ScheduleType type) {...}
  void updateCustomDays(List<int> days) {...}
  bool validate() {...}
  Future<void> submit() async {...}
}
```

### 6. Optimistic Update 구현
```dart
// toggleCompletion with optimistic update
Future<void> toggleCompletion(String routineId) async {
  // 1. 즉시 UI 업데이트 (Optimistic)
  state.whenData((routines) {
    final index = routines.indexWhere((r) => r.id == routineId);
    if (index != -1) {
      final updated = [...routines];
      updated[index] = routines[index].copyWith(
        isCompletedToday: !routines[index].isCompletedToday,
      );
      state = AsyncValue.data(updated);
    }
  });

  // 2. 실제 DB 업데이트
  try {
    await _repository.toggleCompletion(routineId, DateTime.now());
  } catch (e) {
    // 3. 실패 시 롤백
    await loadRoutines();
    throw e;
  }
}
```

### 7. Stream 연동
```dart
// 실시간 데이터 동기화
final routineStreamProvider = StreamProvider<List<Routine>>((ref) {
  final repository = ref.watch(routineRepositoryProvider);
  return repository.watchRoutines();
});

// Auto-dispose provider
final selectedRoutineProvider = StateProvider.autoDispose<Routine?>((ref) => null);
```

## 🔄 데이터 플로우

```
UI (Widget)
    ↓ User Action
Provider (State)
    ↓ Business Logic
Repository
    ↓ Data Operation
Database (SQLite)
    ↓ Result
Repository
    ↓ Data Model
Provider (State Update)
    ↓ Rebuild
UI (Widget)
```

## 🧪 테스트 계획
1. **Provider 테스트**
   - 상태 변경 테스트
   - 비즈니스 로직 테스트
   - 에러 처리 테스트

2. **Notifier 테스트**
   - 메서드 단위 테스트
   - 상태 전환 테스트

3. **통합 테스트**
   - UI-Provider-Repository 전체 플로우
   - Optimistic update 동작
   - Stream 동기화

## ⚠️ 주의사항
1. **Memory Leak 방지**
   - autoDispose 활용
   - Stream 구독 관리
   - Provider 생명주기 관리

2. **성능 최적화**
   - 불필요한 rebuild 방지
   - select 활용
   - family modifier 적절히 사용

3. **에러 처리**
   - AsyncValue 에러 상태 처리
   - 사용자 친화적 에러 메시지
   - 롤백 메커니즘

## 🎯 완료 기준
- [ ] 모든 Provider 구현 완료
- [ ] UI-데이터 실시간 동기화
- [ ] Optimistic update 정상 동작
- [ ] 필터/정렬 기능 구현
- [ ] 에러 처리 및 로딩 상태 관리

## 📝 다음 단계
Phase 4: 테스트 및 성능 최적화로 진행