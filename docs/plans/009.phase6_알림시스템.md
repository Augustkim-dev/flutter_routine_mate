# 009. Phase 6: 알림 시스템 구현 (Post-MVP)

## 📋 작업 개요
**목표**: 루틴 리마인더 및 격려 알림 시스템 구현
**예상 기간**: 2일
**우선순위**: P1 (Post-MVP)

## 🎯 작업 목표
1. 로컬 알림 시스템 구축
2. 루틴별 리마인더 설정
3. 스트릭 축하 알림
4. 알림 권한 요청 플로우
5. 알림 설정 관리 UI

## 📂 생성할 파일 구조
```
lib/
├── core/
│   └── services/
│       ├── notification_service.dart
│       ├── permission_service.dart
│       └── timezone_service.dart
└── features/
    └── notification/
        ├── data/
        │   ├── models/
        │   │   └── notification_settings_model.dart
        │   └── repositories/
        │       └── notification_repository_impl.dart
        ├── domain/
        │   ├── entities/
        │   │   └── notification_settings.dart
        │   └── usecases/
        │       ├── schedule_reminder_usecase.dart
        │       ├── cancel_reminder_usecase.dart
        │       └── show_streak_notification_usecase.dart
        └── presentation/
            ├── screens/
            │   └── notification_settings_screen.dart
            └── widgets/
                ├── reminder_time_picker.dart
                ├── notification_permission_dialog.dart
                └── notification_test_button.dart
```

## 🔧 상세 구현 계획

### 1. 알림 서비스 초기화
```dart
// notification_service.dart
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest_all.dart' as tz;

class NotificationService {
  static final NotificationService _instance = NotificationService._internal();
  factory NotificationService() => _instance;
  NotificationService._internal();

  final FlutterLocalNotificationsPlugin _notifications =
      FlutterLocalNotificationsPlugin();

  Future<void> initialize() async {
    // Timezone 초기화
    tz.initializeTimeZones();
    final String currentTimeZone = await _getCurrentTimeZone();
    tz.setLocalLocation(tz.getLocation(currentTimeZone));

    // Android 설정
    const androidSettings = AndroidInitializationSettings('@mipmap/ic_launcher');

    // iOS 설정
    final DarwinInitializationSettings iosSettings = DarwinInitializationSettings(
      requestAlertPermission: false, // 수동으로 요청
      requestBadgePermission: false,
      requestSoundPermission: false,
      onDidReceiveLocalNotification: _onDidReceiveLocalNotification,
    );

    // 초기화
    final InitializationSettings settings = InitializationSettings(
      android: androidSettings,
      iOS: iosSettings,
    );

    await _notifications.initialize(
      settings,
      onDidReceiveNotificationResponse: _onNotificationTapped,
    );

    // Android 13+ 알림 권한 요청
    await _requestAndroidNotificationPermission();
  }

  Future<void> _requestAndroidNotificationPermission() async {
    if (Platform.isAndroid) {
      final AndroidFlutterLocalNotificationsPlugin? androidPlugin =
          _notifications.resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>();

      await androidPlugin?.requestNotificationsPermission();
    }
  }
}
```

### 2. 루틴 리마인더
```dart
// 루틴별 알림 스케줄링
class NotificationService {
  // 채널 정의
  static const channelReminder = AndroidNotificationDetails(
    'routine_reminder',
    '루틴 리마인더',
    description: '설정한 시간에 루틴을 알려드립니다',
    importance: Importance.high,
    priority: Priority.high,
    playSound: true,
    enableVibration: true,
    styleInformation: BigTextStyleInformation(''),
  );

  static const channelStreak = AndroidNotificationDetails(
    'streak_celebration',
    '스트릭 축하',
    description: '연속 달성을 축하합니다',
    importance: Importance.max,
    priority: Priority.max,
    playSound: true,
    enableVibration: true,
  );

  // 리마인더 스케줄
  Future<void> scheduleRoutineReminder({
    required String routineId,
    required String routineName,
    required TimeOfDay reminderTime,
    required List<int> weekdays, // 0=Mon, 6=Sun
  }) async {
    // 기존 알림 취소
    await cancelRoutineReminder(routineId);

    // 각 요일별로 알림 스케줄
    for (int weekday in weekdays) {
      final int notificationId = _generateNotificationId(routineId, weekday);

      await _notifications.zonedSchedule(
        notificationId,
        '🔔 $routineName 시간이에요!',
        '오늘도 작은 실천을 시작해보세요',
        _nextWeekdayTime(weekday, reminderTime),
        NotificationDetails(
          android: channelReminder,
          iOS: DarwinNotificationDetails(
            presentAlert: true,
            presentBadge: true,
            presentSound: true,
            sound: 'default',
            categoryIdentifier: 'ROUTINE_REMINDER',
          ),
        ),
        androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
        uiLocalNotificationDateInterpretation:
            UILocalNotificationDateInterpretation.absoluteTime,
        matchDateTimeComponents: DateTimeComponents.dayOfWeekAndTime,
        payload: jsonEncode({
          'type': 'reminder',
          'routineId': routineId,
          'routineName': routineName,
        }),
      );
    }
  }

  // 다음 특정 요일의 시간 계산
  tz.TZDateTime _nextWeekdayTime(int weekday, TimeOfDay time) {
    final tz.TZDateTime now = tz.TZDateTime.now(tz.local);
    tz.TZDateTime scheduledDate = tz.TZDateTime(
      tz.local,
      now.year,
      now.month,
      now.day,
      time.hour,
      time.minute,
    );

    // 요일 조정 (DateTime: 1=Mon, 7=Sun)
    int daysToAdd = (weekday + 1 - scheduledDate.weekday) % 7;
    if (daysToAdd == 0 && scheduledDate.isBefore(now)) {
      daysToAdd = 7; // 다음 주
    }

    return scheduledDate.add(Duration(days: daysToAdd));
  }

  // 알림 취소
  Future<void> cancelRoutineReminder(String routineId) async {
    // 해당 루틴의 모든 요일 알림 취소
    for (int weekday = 0; weekday < 7; weekday++) {
      final int notificationId = _generateNotificationId(routineId, weekday);
      await _notifications.cancel(notificationId);
    }
  }

  int _generateNotificationId(String routineId, int weekday) {
    // routineId의 해시코드와 요일 조합으로 고유 ID 생성
    return (routineId.hashCode + weekday) % 1000000;
  }
}
```

### 3. 스트릭 축하 알림
```dart
class StreakNotificationService {
  final NotificationService _notificationService;

  StreakNotificationService(this._notificationService);

  // 스트릭 체크 및 알림
  Future<void> checkAndNotifyStreak(Routine routine) async {
    final int streak = routine.currentStreak;

    // 마일스톤 체크
    final milestones = [3, 7, 14, 30, 50, 100, 365];
    if (!milestones.contains(streak)) return;

    // 알림 내용 생성
    final (String title, String body, String emoji) = _getStreakMessage(streak);

    await _showStreakNotification(
      routine: routine,
      title: '$emoji $title',
      body: body,
      streak: streak,
    );
  }

  (String, String, String) _getStreakMessage(int streak) {
    switch (streak) {
      case 3:
        return ('3일 연속 달성!', '좋은 시작이에요! 계속 이어가보세요', '🔥');
      case 7:
        return ('일주일 달성!', '놀라워요! 습관이 되어가고 있어요', '⭐');
      case 14:
        return ('2주 연속!', '대단해요! 이제 몸에 익숙해지고 있어요', '💪');
      case 30:
        return ('한 달 완주!', '정말 대단해요! 당신은 할 수 있어요', '🏆');
      case 50:
        return ('50일 연속!', '믿을 수 없어요! 당신의 의지력은 정말 강해요', '💎');
      case 100:
        return ('100일 돌파!', '전설이 되셨군요! 정말 자랑스러워요', '👑');
      case 365:
        return ('1년 달성!', '당신은 진정한 챔피언입니다!', '🎊');
      default:
        return ('', '', '');
    }
  }

  Future<void> _showStreakNotification({
    required Routine routine,
    required String title,
    required String body,
    required int streak,
  }) async {
    await _notificationService._notifications.show(
      routine.id.hashCode + 10000 + streak, // 고유 ID
      title,
      '${routine.name}: $body',
      NotificationDetails(
        android: NotificationService.channelStreak,
        iOS: DarwinNotificationDetails(
          presentAlert: true,
          presentBadge: true,
          presentSound: true,
          interruptionLevel: InterruptionLevel.active,
        ),
      ),
      payload: jsonEncode({
        'type': 'streak',
        'routineId': routine.id,
        'streak': streak,
      }),
    );

    // 통계 기록
    await _recordStreakAchievement(routine.id, streak);
  }
}
```

### 4. 권한 요청 플로우
```dart
// permission_service.dart
class PermissionService {
  static Future<bool> requestNotificationPermission(BuildContext context) async {
    // iOS 권한 요청
    if (Platform.isIOS) {
      final bool? granted = await NotificationService()
          ._notifications
          .resolvePlatformSpecificImplementation<
              IOSFlutterLocalNotificationsPlugin>()
          ?.requestPermissions(
            alert: true,
            badge: true,
            sound: true,
          );
      return granted ?? false;
    }

    // Android 13+ 권한 요청
    if (Platform.isAndroid) {
      final status = await Permission.notification.request();

      if (status.isDenied) {
        _showPermissionDeniedDialog(context);
        return false;
      }

      if (status.isPermanentlyDenied) {
        _showOpenSettingsDialog(context);
        return false;
      }

      return status.isGranted;
    }

    return true;
  }

  static void _showPermissionDeniedDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('알림 권한 필요'),
        content: Text(
          '루틴 리마인더와 축하 메시지를 받으려면 알림 권한이 필요합니다.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('나중에'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await requestNotificationPermission(context);
            },
            child: Text('허용하기'),
          ),
        ],
      ),
    );
  }

  static void _showOpenSettingsDialog(BuildContext context) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('설정에서 권한 허용'),
        content: Text(
          '알림 권한이 거부되었습니다.\n설정 > 앱 > RoutineMate에서 알림을 허용해주세요.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('취소'),
          ),
          ElevatedButton(
            onPressed: () {
              openAppSettings();
              Navigator.pop(context);
            },
            child: Text('설정 열기'),
          ),
        ],
      ),
    );
  }
}
```

### 5. 알림 설정 화면
```dart
// notification_settings_screen.dart
class NotificationSettingsScreen extends ConsumerStatefulWidget {
  @override
  _NotificationSettingsScreenState createState() =>
      _NotificationSettingsScreenState();
}

class _NotificationSettingsScreenState
    extends ConsumerState<NotificationSettingsScreen> {
  bool _notificationsEnabled = false;
  bool _reminderEnabled = false;
  bool _streakEnabled = true;
  TimeOfDay _defaultReminderTime = TimeOfDay(hour: 20, minute: 0);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text('알림 설정'),
      ),
      body: ListView(
        children: [
          // 마스터 토글
          SwitchListTile(
            title: Text('알림 받기'),
            subtitle: Text('모든 알림을 켜거나 끕니다'),
            value: _notificationsEnabled,
            onChanged: (value) async {
              if (value) {
                final granted = await PermissionService
                    .requestNotificationPermission(context);
                if (granted) {
                  setState(() => _notificationsEnabled = true);
                }
              } else {
                setState(() => _notificationsEnabled = false);
                await _cancelAllNotifications();
              }
            },
          ),

          Divider(),

          // 리마인더 설정
          SwitchListTile(
            title: Text('루틴 리마인더'),
            subtitle: Text('설정한 시간에 루틴을 알려드립니다'),
            value: _reminderEnabled && _notificationsEnabled,
            onChanged: _notificationsEnabled
                ? (value) => setState(() => _reminderEnabled = value)
                : null,
          ),

          ListTile(
            title: Text('기본 알림 시간'),
            subtitle: Text(_defaultReminderTime.format(context)),
            trailing: Icon(Icons.access_time),
            enabled: _reminderEnabled && _notificationsEnabled,
            onTap: () async {
              final time = await showTimePicker(
                context: context,
                initialTime: _defaultReminderTime,
              );
              if (time != null) {
                setState(() => _defaultReminderTime = time);
                await _updateDefaultReminderTime(time);
              }
            },
          ),

          Divider(),

          // 스트릭 알림
          SwitchListTile(
            title: Text('연속 달성 축하'),
            subtitle: Text('3일, 7일, 30일 등 연속 달성 시 축하 메시지'),
            value: _streakEnabled && _notificationsEnabled,
            onChanged: _notificationsEnabled
                ? (value) => setState(() => _streakEnabled = value)
                : null,
          ),

          Divider(),

          // 테스트 버튼
          Padding(
            padding: EdgeInsets.all(16),
            child: ElevatedButton.icon(
              onPressed: _notificationsEnabled ? _sendTestNotification : null,
              icon: Icon(Icons.notifications_active),
              label: Text('테스트 알림 보내기'),
            ),
          ),

          // 루틴별 개별 설정
          Padding(
            padding: EdgeInsets.all(16),
            child: Text(
              '루틴별 알림 설정',
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ),

          _buildRoutineNotificationList(),
        ],
      ),
    );
  }

  Widget _buildRoutineNotificationList() {
    final routines = ref.watch(routineListProvider);

    return routines.when(
      data: (list) => Column(
        children: list.map((routine) {
          return ListTile(
            leading: Icon(
              getIconData(routine.iconIndex),
              color: getColor(routine.colorIndex),
            ),
            title: Text(routine.name),
            subtitle: routine.isReminderEnabled
                ? Text('알림: ${routine.reminderTime ?? _defaultReminderTime.format(context)}')
                : Text('알림 꺼짐'),
            trailing: Switch(
              value: routine.isReminderEnabled,
              onChanged: _notificationsEnabled && _reminderEnabled
                  ? (value) => _toggleRoutineReminder(routine, value)
                  : null,
            ),
            onTap: routine.isReminderEnabled
                ? () => _editRoutineReminderTime(routine)
                : null,
          );
        }).toList(),
      ),
      loading: () => CircularProgressIndicator(),
      error: (error, stack) => Text('오류 발생'),
    );
  }

  Future<void> _sendTestNotification() async {
    await NotificationService()._notifications.show(
      999999,
      '🔔 테스트 알림',
      'RoutineMate 알림이 정상적으로 작동합니다!',
      NotificationDetails(
        android: NotificationService.channelReminder,
        iOS: DarwinNotificationDetails(),
      ),
    );
  }
}
```

### 6. 알림 클릭 처리
```dart
// notification_service.dart
void _onNotificationTapped(NotificationResponse response) {
  if (response.payload != null) {
    final Map<String, dynamic> data = jsonDecode(response.payload!);
    final String type = data['type'];
    final String routineId = data['routineId'];

    switch (type) {
      case 'reminder':
        // 해당 루틴으로 이동
        navigatorKey.currentState?.pushNamed(
          '/home',
          arguments: {'highlightRoutineId': routineId},
        );
        break;

      case 'streak':
        // 통계 화면으로 이동
        navigatorKey.currentState?.pushNamed(
          '/statistics',
          arguments: {'routineId': routineId},
        );
        break;
    }
  }
}
```

## 🧪 테스트 계획
1. **권한 테스트**
   - iOS/Android 권한 요청
   - 권한 거부 시 처리
   - 설정 화면 이동

2. **스케줄링 테스트**
   - 정확한 시간에 알림
   - 요일별 반복
   - 시간대 변경 처리

3. **알림 테스트**
   - 포그라운드/백그라운드
   - 알림 탭 액션
   - 다양한 메시지 포맷

## ⚠️ 주의사항
1. **플랫폼별 제약**
   - iOS: 64개 알림 제한
   - Android: 정확한 알림 배터리 최적화
   - 시간대 변경 고려

2. **사용자 경험**
   - 과도한 알림 방지
   - 방해금지 모드 존중
   - 명확한 옵트아웃

3. **배터리 최적화**
   - 효율적인 스케줄링
   - 불필요한 웨이크업 방지

## 🎯 완료 기준
- [ ] 알림 권한 요청 플로우
- [ ] 루틴 리마인더 정상 작동
- [ ] 스트릭 축하 알림
- [ ] 알림 설정 UI 구현
- [ ] 알림 클릭 액션 처리

## 📝 다음 단계
Phase 7: 통계 및 분석 기능으로 진행