# 003. ë°ì´í„°ë² ì´ìŠ¤ ë³€ê²½ (Hive â†’ SQLite)

## ğŸ“‹ ì‘ì—… ê°œìš”
- **ì‘ì—…ì¼**: 2025.10.08
- **ì‘ì—…ì**: August Kim
- **ì˜ˆìƒ ì†Œìš”ì‹œê°„**: 4ì‹œê°„
- **ê´€ë ¨ ì´ìŠˆ**: PRD ë°ì´í„°ë² ì´ìŠ¤ ê¸°ìˆ  ìŠ¤íƒ ë³€ê²½

## ğŸ¯ ì‘ì—… ëª©í‘œ
- [ ] Hiveì—ì„œ SQLiteë¡œ ë°ì´í„°ë² ì´ìŠ¤ ë³€ê²½ ê²°ì •
- [ ] SQLite ìŠ¤í‚¤ë§ˆ ì„¤ê³„
- [ ] Repository íŒ¨í„´ìœ¼ë¡œ ë°ì´í„° ì ‘ê·¼ ê³„ì¸µ êµ¬í˜„
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ ìˆ˜ë¦½

## ğŸ”„ ë³€ê²½ ì´ìœ 

### Hiveì˜ í•œê³„ì 
1. **ë³µì¡í•œ ì¿¼ë¦¬ ë¶ˆê°€**: NoSQL íŠ¹ì„±ìƒ ê´€ê³„í˜• ë°ì´í„° ì²˜ë¦¬ ì–´ë ¤ì›€
2. **ë°ì´í„° ë¬´ê²°ì„±**: ìŠ¤í‚¤ë§ˆ ë³€ê²½ ì‹œ íƒ€ì… ì•ˆì •ì„± ë¶€ì¡±
3. **í™•ì¥ì„± ì œí•œ**: í–¥í›„ ì„œë²„ ë™ê¸°í™” ì‹œ SQL ê¸°ë°˜ì´ ìœ ë¦¬
4. **ë°±ì—…/ë³µì›**: SQLiteê°€ ë” ì•ˆì •ì ì¸ ë°±ì—… ë©”ì»¤ë‹ˆì¦˜ ì œê³µ

### SQLite ì„ íƒ ì´ìœ 
1. **ê´€ê³„í˜• ë°ì´í„°**: ë£¨í‹´ê³¼ ì™„ë£Œ ê¸°ë¡ ê°„ ê´€ê³„ ëª…í™•íˆ í‘œí˜„
2. **ë³µì¡í•œ ì¿¼ë¦¬**: í†µê³„, í•„í„°ë§, ì •ë ¬ ë“± SQLë¡œ íš¨ìœ¨ì  ì²˜ë¦¬
3. **í‘œì¤€í™”**: SQL í‘œì¤€ ì¤€ìˆ˜ë¡œ í–¥í›„ ì„œë²„ DB ì´ì „ ìš©ì´
4. **ì„±ìˆ™ë„**: ì˜¤ëœ ê¸°ê°„ ê²€ì¦ëœ ì•ˆì •ì„±
5. **íŠ¸ëœì­ì…˜**: ACID íŠ¹ì„± ë³´ì¥ìœ¼ë¡œ ë°ì´í„° ë¬´ê²°ì„± í™•ë³´

## ğŸ“ ê¸°ìˆ ì  ì ‘ê·¼

### ì‚¬ìš©í•  íŒ¨í‚¤ì§€
- **sqflite**: ^2.3.0 - Flutter SQLite í”ŒëŸ¬ê·¸ì¸
- **path**: ^1.8.3 - ë°ì´í„°ë² ì´ìŠ¤ íŒŒì¼ ê²½ë¡œ ê´€ë¦¬
- **sqflite_common_ffi**: ^2.3.0 - ë°ìŠ¤í¬í†± í…ŒìŠ¤íŠ¸ìš©

### ì•„í‚¤í…ì²˜ ê²°ì •ì‚¬í•­
1. **Repository íŒ¨í„´**: ë°ì´í„° ì ‘ê·¼ ë¡œì§ ì¶”ìƒí™”
2. **DAO íŒ¨í„´**: ê° í…Œì´ë¸”ë³„ Data Access Object
3. **Migration ì‹œìŠ¤í…œ**: ë²„ì „ë³„ ìŠ¤í‚¤ë§ˆ ì—…ê·¸ë ˆì´ë“œ
4. **Transaction í™œìš©**: ë³µì¡í•œ ì‘ì—… ì›ìì„± ë³´ì¥

## ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

### í…Œì´ë¸” êµ¬ì¡°

```sql
-- 1. routines í…Œì´ë¸”
CREATE TABLE routines (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL CHECK(length(name) BETWEEN 1 AND 20),
    icon_index INTEGER NOT NULL CHECK(icon_index BETWEEN 0 AND 29),
    color_index INTEGER NOT NULL CHECK(color_index BETWEEN 0 AND 7),
    schedule_type TEXT NOT NULL CHECK(schedule_type IN ('DAILY', 'WEEKDAY', 'WEEKEND', 'CUSTOM')),
    custom_days TEXT, -- JSON array: [1,2,3,4,5] for Mon-Fri
    sort_order INTEGER NOT NULL DEFAULT 0,
    reminder_time TEXT, -- HH:mm format
    is_reminder_enabled INTEGER DEFAULT 0, -- Boolean: 0 or 1
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TEXT -- Soft delete
);

-- 2. completion_records í…Œì´ë¸”
CREATE TABLE completion_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    routine_id TEXT NOT NULL,
    date TEXT NOT NULL, -- YYYY-MM-DD format
    is_completed INTEGER NOT NULL DEFAULT 0, -- Boolean
    completed_at TEXT,
    note TEXT,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (routine_id) REFERENCES routines(id) ON DELETE CASCADE,
    UNIQUE(routine_id, date) -- í•˜ë£¨ì— í•˜ë‚˜ì˜ ê¸°ë¡ë§Œ
);

-- 3. app_settings í…Œì´ë¸”
CREATE TABLE app_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 4. analytics_data í…Œì´ë¸”
CREATE TABLE analytics_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL UNIQUE,
    total_routines INTEGER DEFAULT 0,
    completed_routines INTEGER DEFAULT 0,
    app_open_count INTEGER DEFAULT 0,
    check_from_widget INTEGER DEFAULT 0,
    check_from_app INTEGER DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_routines_deleted_at ON routines(deleted_at);
CREATE INDEX idx_routines_sort_order ON routines(sort_order);
CREATE INDEX idx_completion_records_routine_id ON completion_records(routine_id);
CREATE INDEX idx_completion_records_date ON completion_records(date);
CREATE INDEX idx_completion_records_routine_date ON completion_records(routine_id, date);
CREATE INDEX idx_analytics_data_date ON analytics_data(date);
```

## ğŸ“ ì˜ˆìƒ íŒŒì¼ êµ¬ì¡°

```
lib/
â”œâ”€â”€ core/
â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ database_helper.dart      # SQLite ì´ˆê¸°í™” ë° ë§ˆì´ê·¸ë ˆì´ì…˜
â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”‚   â”œâ”€â”€ migration_v1.dart     # ì´ˆê¸° ìŠ¤í‚¤ë§ˆ
â”‚   â”‚   â”‚   â””â”€â”€ migration_v2.dart     # í–¥í›„ ì—…ë°ì´íŠ¸
â”‚   â”‚   â””â”€â”€ tables.dart               # í…Œì´ë¸” ë° ì»¬ëŸ¼ëª… ìƒìˆ˜
â”‚   â””â”€â”€ models/
â”‚       â”œâ”€â”€ routine_model.dart        # Routine ë„ë©”ì¸ ëª¨ë¸
â”‚       â”œâ”€â”€ completion_model.dart     # CompletionRecord ëª¨ë¸
â”‚       â””â”€â”€ settings_model.dart       # AppSettings ëª¨ë¸
â”œâ”€â”€ features/
â”‚   â””â”€â”€ routine/
â”‚       â”œâ”€â”€ data/
â”‚       â”‚   â”œâ”€â”€ datasources/
â”‚       â”‚   â”‚   â””â”€â”€ routine_dao.dart  # Routine í…Œì´ë¸” ì ‘ê·¼
â”‚       â”‚   â””â”€â”€ repositories/
â”‚       â”‚       â””â”€â”€ routine_repository_impl.dart
â”‚       â”œâ”€â”€ domain/
â”‚       â”‚   â”œâ”€â”€ entities/
â”‚       â”‚   â”‚   â””â”€â”€ routine.dart
â”‚       â”‚   â””â”€â”€ repositories/
â”‚       â”‚       â””â”€â”€ routine_repository.dart
â”‚       â””â”€â”€ presentation/
â””â”€â”€ main.dart
```

## ğŸ’» ì£¼ìš” êµ¬í˜„ ì½”ë“œ

### DatabaseHelper
```dart
class DatabaseHelper {
  static const String _databaseName = 'routine_mate.db';
  static const int _databaseVersion = 1;

  Database? _database;

  Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    final path = join(await getDatabasesPath(), _databaseName);

    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    // í…Œì´ë¸” ìƒì„±
    await db.execute(Tables.createRoutinesTable);
    await db.execute(Tables.createCompletionRecordsTable);
    await db.execute(Tables.createAppSettingsTable);
    await db.execute(Tables.createAnalyticsDataTable);

    // ì¸ë±ìŠ¤ ìƒì„±
    await db.execute(Tables.createIndexes);
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // í–¥í›„ ë§ˆì´ê·¸ë ˆì´ì…˜ ë¡œì§
  }
}
```

### Routine DAO
```dart
class RoutineDao {
  final DatabaseHelper _dbHelper;

  RoutineDao(this._dbHelper);

  Future<List<RoutineModel>> getAllRoutines() async {
    final db = await _dbHelper.database;
    final List<Map<String, dynamic>> maps = await db.query(
      'routines',
      where: 'deleted_at IS NULL',
      orderBy: 'sort_order ASC, created_at DESC',
    );

    return List.generate(maps.length, (i) => RoutineModel.fromMap(maps[i]));
  }

  Future<void> insertRoutine(RoutineModel routine) async {
    final db = await _dbHelper.database;
    await db.insert(
      'routines',
      routine.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<void> toggleCompletion(String routineId, String date) async {
    final db = await _dbHelper.database;

    await db.transaction((txn) async {
      // í˜„ì¬ ìƒíƒœ í™•ì¸
      final existing = await txn.query(
        'completion_records',
        where: 'routine_id = ? AND date = ?',
        whereArgs: [routineId, date],
      );

      if (existing.isEmpty) {
        // ìƒˆë¡œ ì¶”ê°€
        await txn.insert('completion_records', {
          'routine_id': routineId,
          'date': date,
          'is_completed': 1,
          'completed_at': DateTime.now().toIso8601String(),
        });
      } else {
        // í† ê¸€
        final current = existing.first['is_completed'] as int;
        await txn.update(
          'completion_records',
          {
            'is_completed': current == 0 ? 1 : 0,
            'completed_at': current == 0 ? DateTime.now().toIso8601String() : null,
          },
          where: 'routine_id = ? AND date = ?',
          whereArgs: [routineId, date],
        );
      }

      // í†µê³„ ì—…ë°ì´íŠ¸
      await _updateAnalytics(txn, date, 'check_from_app');
    });
  }

  Future<Map<String, bool>> getCompletionHistory(String routineId) async {
    final db = await _dbHelper.database;
    final records = await db.query(
      'completion_records',
      where: 'routine_id = ?',
      whereArgs: [routineId],
      orderBy: 'date DESC',
      limit: 365, // ìµœê·¼ 1ë…„ì¹˜ë§Œ
    );

    return Map.fromEntries(
      records.map((r) => MapEntry(
        r['date'] as String,
        r['is_completed'] == 1,
      )),
    );
  }

  Future<int> getCurrentStreak(String routineId) async {
    final db = await _dbHelper.database;

    // SQLë¡œ ì—°ì† ì™„ë£Œ ì¼ìˆ˜ ê³„ì‚°
    final result = await db.rawQuery('''
      WITH consecutive_days AS (
        SELECT
          date,
          is_completed,
          date(date, '-' || ROW_NUMBER() OVER (ORDER BY date DESC) || ' days') as group_date
        FROM completion_records
        WHERE routine_id = ? AND is_completed = 1
        ORDER BY date DESC
      )
      SELECT COUNT(*) as streak
      FROM consecutive_days
      WHERE group_date = (
        SELECT MAX(group_date)
        FROM consecutive_days
      )
    ''', [routineId]);

    return result.first['streak'] as int? ?? 0;
  }
}
```

### Repository Implementation
```dart
class RoutineRepositoryImpl implements RoutineRepository {
  final RoutineDao _routineDao;

  RoutineRepositoryImpl(this._routineDao);

  @override
  Future<List<Routine>> getAllRoutines() async {
    final models = await _routineDao.getAllRoutines();

    // ê° ë£¨í‹´ì˜ ì™„ë£Œ ê¸°ë¡ë„ í•¨ê»˜ ë¡œë“œ
    final routines = <Routine>[];
    for (final model in models) {
      final history = await _routineDao.getCompletionHistory(model.id);
      final streak = await _routineDao.getCurrentStreak(model.id);

      routines.add(model.toDomain(
        completionHistory: history,
        currentStreak: streak,
      ));
    }

    return routines;
  }

  @override
  Stream<List<Routine>> watchRoutines() {
    // StreamControllerë¥¼ ì‚¬ìš©í•œ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸
    final controller = StreamController<List<Routine>>.broadcast();

    // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
    getAllRoutines().then(controller.add);

    // DB ë³€ê²½ ê°ì§€ (í´ë§ ë˜ëŠ” ì´ë²¤íŠ¸ ê¸°ë°˜)
    Timer.periodic(Duration(seconds: 1), (_) async {
      final routines = await getAllRoutines();
      controller.add(routines);
    });

    return controller.stream;
  }
}
```

## âœ… í…ŒìŠ¤íŠ¸ ê³„íš

### Unit Tests
- [ ] DatabaseHelper ì´ˆê¸°í™” í…ŒìŠ¤íŠ¸
- [ ] í…Œì´ë¸” ìƒì„± í™•ì¸
- [ ] CRUD ì‘ì—… í…ŒìŠ¤íŠ¸
- [ ] íŠ¸ëœì­ì…˜ ë¡¤ë°± í…ŒìŠ¤íŠ¸
- [ ] ë§ˆì´ê·¸ë ˆì´ì…˜ í…ŒìŠ¤íŠ¸

### Integration Tests
- [ ] ë£¨í‹´ ì¶”ê°€ â†’ ì¡°íšŒ í†µí•© í…ŒìŠ¤íŠ¸
- [ ] ì™„ë£Œ ì²´í¬ â†’ íˆìŠ¤í† ë¦¬ í™•ì¸
- [ ] ìŠ¤íŠ¸ë¦­ ê³„ì‚° ì •í™•ë„
- [ ] ë™ì‹œì„± í…ŒìŠ¤íŠ¸ (multiple operations)

### Performance Tests
- [ ] 1000ê°œ ë£¨í‹´ ì¡°íšŒ ì„±ëŠ¥
- [ ] ë³µì¡í•œ ì¿¼ë¦¬ ì‹¤í–‰ ì‹œê°„
- [ ] ì¸ë±ìŠ¤ íš¨ê³¼ ì¸¡ì •
- [ ] íŠ¸ëœì­ì…˜ ì˜¤ë²„í—¤ë“œ

## âš ï¸ ì˜ˆìƒ ì´ìŠˆ

### 1. ë§ˆì´ê·¸ë ˆì´ì…˜
- **ì´ìŠˆ**: ê¸°ì¡´ Hive ì‚¬ìš©ì ë°ì´í„° ì´ì „
- **ëŒ€ì‘**: ì²« ì‹¤í–‰ ì‹œ Hive â†’ SQLite ìë™ ë§ˆì´ê·¸ë ˆì´ì…˜ ë„êµ¬ ì œê³µ

### 2. ë‚ ì§œ/ì‹œê°„ ì²˜ë¦¬
- **ì´ìŠˆ**: SQLiteëŠ” ë‚ ì§œ íƒ€ì…ì´ ì—†ìŒ
- **ëŒ€ì‘**: ISO 8601 ë¬¸ìì—´ë¡œ ì €ì¥, ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ì—ì„œ íŒŒì‹±

### 3. Boolean ì²˜ë¦¬
- **ì´ìŠˆ**: SQLiteëŠ” boolean íƒ€ì…ì´ ì—†ìŒ
- **ëŒ€ì‘**: INTEGER (0/1)ë¡œ ì €ì¥, ëª¨ë¸ì—ì„œ ë³€í™˜

### 4. ë™ì‹œì„±
- **ì´ìŠˆ**: ë‹¤ì¤‘ ì“°ê¸° ì‘ì—… ì‹œ lock
- **ëŒ€ì‘**: íŠ¸ëœì­ì…˜ ì‚¬ìš©, ì ì ˆí•œ íƒ€ì„ì•„ì›ƒ ì„¤ì •

## ğŸ“š ì°¸ê³  ìë£Œ
- [sqflite ê³µì‹ ë¬¸ì„œ](https://pub.dev/packages/sqflite)
- [SQLite ë°ì´í„° íƒ€ì…](https://www.sqlite.org/datatype3.html)
- [Flutter Database ë¹„êµ](https://flutter.dev/docs/cookbook/persistence/sqlite)
- [SQL ì„±ëŠ¥ ìµœì í™”](https://www.sqlite.org/optoverview.html)

## ğŸ”„ Hive â†’ SQLite ë§ˆì´ê·¸ë ˆì´ì…˜ ì „ëµ

### ë‹¨ê³„ë³„ ê³„íš
1. **ê°ì§€**: ì•± ì‹œì‘ ì‹œ Hive ë°ì´í„° ì¡´ì¬ í™•ì¸
2. **ì½ê¸°**: Hive Boxì—ì„œ ëª¨ë“  ë°ì´í„° ì½ê¸°
3. **ë³€í™˜**: Hive ëª¨ë¸ â†’ SQLite ëª¨ë¸ ë³€í™˜
4. **ì €ì¥**: SQLiteì— íŠ¸ëœì­ì…˜ìœ¼ë¡œ ì¼ê´„ ì €ì¥
5. **ê²€ì¦**: ë°ì´í„° ë¬´ê²°ì„± í™•ì¸
6. **ì •ë¦¬**: ì„±ê³µ ì‹œ Hive ë°ì´í„° ë°±ì—… í›„ ì‚­ì œ

### ë§ˆì´ê·¸ë ˆì´ì…˜ ì½”ë“œ
```dart
class DataMigrator {
  Future<bool> migrateFromHiveToSQLite() async {
    try {
      // 1. Hive ì´ˆê¸°í™”
      await Hive.initFlutter();

      // 2. Hive Box ì—´ê¸°
      if (!await Hive.boxExists('routines')) {
        return false; // ë§ˆì´ê·¸ë ˆì´ì…˜ ë¶ˆí•„ìš”
      }

      final hiveBox = await Hive.openBox<dynamic>('routines');

      // 3. SQLite ì¤€ë¹„
      final db = await DatabaseHelper().database;

      // 4. íŠ¸ëœì­ì…˜ìœ¼ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜
      await db.transaction((txn) async {
        for (final routine in hiveBox.values) {
          // Hive â†’ SQLite ë³€í™˜
          await txn.insert('routines', _convertToSQLite(routine));

          // ì™„ë£Œ ê¸°ë¡ë„ ë§ˆì´ê·¸ë ˆì´ì…˜
          final history = routine['completionHistory'] as Map?;
          if (history != null) {
            for (final entry in history.entries) {
              await txn.insert('completion_records', {
                'routine_id': routine['id'],
                'date': entry.key,
                'is_completed': entry.value ? 1 : 0,
              });
            }
          }
        }
      });

      // 5. ì„±ê³µ ì‹œ Hive ë°±ì—…
      await _backupHiveData();

      // 6. Hive ë°ì´í„° ì‚­ì œ
      await hiveBox.clear();
      await hiveBox.close();

      return true;
    } catch (e) {
      debugPrint('Migration failed: $e');
      return false;
    }
  }
}
```

---

*ë‹¤ìŒ ë‹¨ê³„: ì‹¤ì œ êµ¬í˜„ í›„ worklogs/003.ë°ì´í„°ë² ì´ìŠ¤_ë³€ê²½_sqlite.md ì‘ì„±*