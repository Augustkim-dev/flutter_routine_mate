# 003. 데이터베이스 변경 (Hive → SQLite)

## 📋 작업 개요
- **작업일**: 2025.10.08
- **작업자**: August Kim
- **예상 소요시간**: 4시간
- **관련 이슈**: PRD 데이터베이스 기술 스택 변경

## 🎯 작업 목표
- [ ] Hive에서 SQLite로 데이터베이스 변경 결정
- [ ] SQLite 스키마 설계
- [ ] Repository 패턴으로 데이터 접근 계층 구현
- [ ] 마이그레이션 전략 수립

## 🔄 변경 이유

### Hive의 한계점
1. **복잡한 쿼리 불가**: NoSQL 특성상 관계형 데이터 처리 어려움
2. **데이터 무결성**: 스키마 변경 시 타입 안정성 부족
3. **확장성 제한**: 향후 서버 동기화 시 SQL 기반이 유리
4. **백업/복원**: SQLite가 더 안정적인 백업 메커니즘 제공

### SQLite 선택 이유
1. **관계형 데이터**: 루틴과 완료 기록 간 관계 명확히 표현
2. **복잡한 쿼리**: 통계, 필터링, 정렬 등 SQL로 효율적 처리
3. **표준화**: SQL 표준 준수로 향후 서버 DB 이전 용이
4. **성숙도**: 오랜 기간 검증된 안정성
5. **트랜잭션**: ACID 특성 보장으로 데이터 무결성 확보

## 📐 기술적 접근

### 사용할 패키지
- **sqflite**: ^2.3.0 - Flutter SQLite 플러그인
- **path**: ^1.8.3 - 데이터베이스 파일 경로 관리
- **sqflite_common_ffi**: ^2.3.0 - 데스크톱 테스트용

### 아키텍처 결정사항
1. **Repository 패턴**: 데이터 접근 로직 추상화
2. **DAO 패턴**: 각 테이블별 Data Access Object
3. **Migration 시스템**: 버전별 스키마 업그레이드
4. **Transaction 활용**: 복잡한 작업 원자성 보장

## 📊 데이터베이스 스키마

### 테이블 구조

```sql
-- 1. routines 테이블
CREATE TABLE routines (
    id TEXT PRIMARY KEY,
    name TEXT NOT NULL CHECK(length(name) BETWEEN 1 AND 20),
    icon_index INTEGER NOT NULL CHECK(icon_index BETWEEN 0 AND 29),
    color_index INTEGER NOT NULL CHECK(color_index BETWEEN 0 AND 7),
    schedule_type TEXT NOT NULL CHECK(schedule_type IN ('DAILY', 'WEEKDAY', 'WEEKEND', 'CUSTOM')),
    custom_days TEXT, -- JSON array: [1,2,3,4,5] for Mon-Fri
    sort_order INTEGER NOT NULL DEFAULT 0,
    reminder_time TEXT, -- HH:mm format
    is_reminder_enabled INTEGER DEFAULT 0, -- Boolean: 0 or 1
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    deleted_at TEXT -- Soft delete
);

-- 2. completion_records 테이블
CREATE TABLE completion_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    routine_id TEXT NOT NULL,
    date TEXT NOT NULL, -- YYYY-MM-DD format
    is_completed INTEGER NOT NULL DEFAULT 0, -- Boolean
    completed_at TEXT,
    note TEXT,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (routine_id) REFERENCES routines(id) ON DELETE CASCADE,
    UNIQUE(routine_id, date) -- 하루에 하나의 기록만
);

-- 3. app_settings 테이블
CREATE TABLE app_settings (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    updated_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 4. analytics_data 테이블
CREATE TABLE analytics_data (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    date TEXT NOT NULL UNIQUE,
    total_routines INTEGER DEFAULT 0,
    completed_routines INTEGER DEFAULT 0,
    app_open_count INTEGER DEFAULT 0,
    check_from_widget INTEGER DEFAULT 0,
    check_from_app INTEGER DEFAULT 0,
    created_at TEXT NOT NULL DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_routines_deleted_at ON routines(deleted_at);
CREATE INDEX idx_routines_sort_order ON routines(sort_order);
CREATE INDEX idx_completion_records_routine_id ON completion_records(routine_id);
CREATE INDEX idx_completion_records_date ON completion_records(date);
CREATE INDEX idx_completion_records_routine_date ON completion_records(routine_id, date);
CREATE INDEX idx_analytics_data_date ON analytics_data(date);
```

## 📁 예상 파일 구조

```
lib/
├── core/
│   ├── database/
│   │   ├── database_helper.dart      # SQLite 초기화 및 마이그레이션
│   │   ├── migrations/
│   │   │   ├── migration_v1.dart     # 초기 스키마
│   │   │   └── migration_v2.dart     # 향후 업데이트
│   │   └── tables.dart               # 테이블 및 컬럼명 상수
│   └── models/
│       ├── routine_model.dart        # Routine 도메인 모델
│       ├── completion_model.dart     # CompletionRecord 모델
│       └── settings_model.dart       # AppSettings 모델
├── features/
│   └── routine/
│       ├── data/
│       │   ├── datasources/
│       │   │   └── routine_dao.dart  # Routine 테이블 접근
│       │   └── repositories/
│       │       └── routine_repository_impl.dart
│       ├── domain/
│       │   ├── entities/
│       │   │   └── routine.dart
│       │   └── repositories/
│       │       └── routine_repository.dart
│       └── presentation/
└── main.dart
```

## 💻 주요 구현 코드

### DatabaseHelper
```dart
class DatabaseHelper {
  static const String _databaseName = 'routine_mate.db';
  static const int _databaseVersion = 1;

  Database? _database;

  Future<Database> get database async {
    _database ??= await _initDatabase();
    return _database!;
  }

  Future<Database> _initDatabase() async {
    final path = join(await getDatabasesPath(), _databaseName);

    return await openDatabase(
      path,
      version: _databaseVersion,
      onCreate: _onCreate,
      onUpgrade: _onUpgrade,
    );
  }

  Future<void> _onCreate(Database db, int version) async {
    // 테이블 생성
    await db.execute(Tables.createRoutinesTable);
    await db.execute(Tables.createCompletionRecordsTable);
    await db.execute(Tables.createAppSettingsTable);
    await db.execute(Tables.createAnalyticsDataTable);

    // 인덱스 생성
    await db.execute(Tables.createIndexes);
  }

  Future<void> _onUpgrade(Database db, int oldVersion, int newVersion) async {
    // 향후 마이그레이션 로직
  }
}
```

### Routine DAO
```dart
class RoutineDao {
  final DatabaseHelper _dbHelper;

  RoutineDao(this._dbHelper);

  Future<List<RoutineModel>> getAllRoutines() async {
    final db = await _dbHelper.database;
    final List<Map<String, dynamic>> maps = await db.query(
      'routines',
      where: 'deleted_at IS NULL',
      orderBy: 'sort_order ASC, created_at DESC',
    );

    return List.generate(maps.length, (i) => RoutineModel.fromMap(maps[i]));
  }

  Future<void> insertRoutine(RoutineModel routine) async {
    final db = await _dbHelper.database;
    await db.insert(
      'routines',
      routine.toMap(),
      conflictAlgorithm: ConflictAlgorithm.replace,
    );
  }

  Future<void> toggleCompletion(String routineId, String date) async {
    final db = await _dbHelper.database;

    await db.transaction((txn) async {
      // 현재 상태 확인
      final existing = await txn.query(
        'completion_records',
        where: 'routine_id = ? AND date = ?',
        whereArgs: [routineId, date],
      );

      if (existing.isEmpty) {
        // 새로 추가
        await txn.insert('completion_records', {
          'routine_id': routineId,
          'date': date,
          'is_completed': 1,
          'completed_at': DateTime.now().toIso8601String(),
        });
      } else {
        // 토글
        final current = existing.first['is_completed'] as int;
        await txn.update(
          'completion_records',
          {
            'is_completed': current == 0 ? 1 : 0,
            'completed_at': current == 0 ? DateTime.now().toIso8601String() : null,
          },
          where: 'routine_id = ? AND date = ?',
          whereArgs: [routineId, date],
        );
      }

      // 통계 업데이트
      await _updateAnalytics(txn, date, 'check_from_app');
    });
  }

  Future<Map<String, bool>> getCompletionHistory(String routineId) async {
    final db = await _dbHelper.database;
    final records = await db.query(
      'completion_records',
      where: 'routine_id = ?',
      whereArgs: [routineId],
      orderBy: 'date DESC',
      limit: 365, // 최근 1년치만
    );

    return Map.fromEntries(
      records.map((r) => MapEntry(
        r['date'] as String,
        r['is_completed'] == 1,
      )),
    );
  }

  Future<int> getCurrentStreak(String routineId) async {
    final db = await _dbHelper.database;

    // SQL로 연속 완료 일수 계산
    final result = await db.rawQuery('''
      WITH consecutive_days AS (
        SELECT
          date,
          is_completed,
          date(date, '-' || ROW_NUMBER() OVER (ORDER BY date DESC) || ' days') as group_date
        FROM completion_records
        WHERE routine_id = ? AND is_completed = 1
        ORDER BY date DESC
      )
      SELECT COUNT(*) as streak
      FROM consecutive_days
      WHERE group_date = (
        SELECT MAX(group_date)
        FROM consecutive_days
      )
    ''', [routineId]);

    return result.first['streak'] as int? ?? 0;
  }
}
```

### Repository Implementation
```dart
class RoutineRepositoryImpl implements RoutineRepository {
  final RoutineDao _routineDao;

  RoutineRepositoryImpl(this._routineDao);

  @override
  Future<List<Routine>> getAllRoutines() async {
    final models = await _routineDao.getAllRoutines();

    // 각 루틴의 완료 기록도 함께 로드
    final routines = <Routine>[];
    for (final model in models) {
      final history = await _routineDao.getCompletionHistory(model.id);
      final streak = await _routineDao.getCurrentStreak(model.id);

      routines.add(model.toDomain(
        completionHistory: history,
        currentStreak: streak,
      ));
    }

    return routines;
  }

  @override
  Stream<List<Routine>> watchRoutines() {
    // StreamController를 사용한 실시간 업데이트
    final controller = StreamController<List<Routine>>.broadcast();

    // 초기 데이터 로드
    getAllRoutines().then(controller.add);

    // DB 변경 감지 (폴링 또는 이벤트 기반)
    Timer.periodic(Duration(seconds: 1), (_) async {
      final routines = await getAllRoutines();
      controller.add(routines);
    });

    return controller.stream;
  }
}
```

## ✅ 테스트 계획

### Unit Tests
- [ ] DatabaseHelper 초기화 테스트
- [ ] 테이블 생성 확인
- [ ] CRUD 작업 테스트
- [ ] 트랜잭션 롤백 테스트
- [ ] 마이그레이션 테스트

### Integration Tests
- [ ] 루틴 추가 → 조회 통합 테스트
- [ ] 완료 체크 → 히스토리 확인
- [ ] 스트릭 계산 정확도
- [ ] 동시성 테스트 (multiple operations)

### Performance Tests
- [ ] 1000개 루틴 조회 성능
- [ ] 복잡한 쿼리 실행 시간
- [ ] 인덱스 효과 측정
- [ ] 트랜잭션 오버헤드

## ⚠️ 예상 이슈

### 1. 마이그레이션
- **이슈**: 기존 Hive 사용자 데이터 이전
- **대응**: 첫 실행 시 Hive → SQLite 자동 마이그레이션 도구 제공

### 2. 날짜/시간 처리
- **이슈**: SQLite는 날짜 타입이 없음
- **대응**: ISO 8601 문자열로 저장, 애플리케이션 레벨에서 파싱

### 3. Boolean 처리
- **이슈**: SQLite는 boolean 타입이 없음
- **대응**: INTEGER (0/1)로 저장, 모델에서 변환

### 4. 동시성
- **이슈**: 다중 쓰기 작업 시 lock
- **대응**: 트랜잭션 사용, 적절한 타임아웃 설정

## 📚 참고 자료
- [sqflite 공식 문서](https://pub.dev/packages/sqflite)
- [SQLite 데이터 타입](https://www.sqlite.org/datatype3.html)
- [Flutter Database 비교](https://flutter.dev/docs/cookbook/persistence/sqlite)
- [SQL 성능 최적화](https://www.sqlite.org/optoverview.html)

## 🔄 Hive → SQLite 마이그레이션 전략

### 단계별 계획
1. **감지**: 앱 시작 시 Hive 데이터 존재 확인
2. **읽기**: Hive Box에서 모든 데이터 읽기
3. **변환**: Hive 모델 → SQLite 모델 변환
4. **저장**: SQLite에 트랜잭션으로 일괄 저장
5. **검증**: 데이터 무결성 확인
6. **정리**: 성공 시 Hive 데이터 백업 후 삭제

### 마이그레이션 코드
```dart
class DataMigrator {
  Future<bool> migrateFromHiveToSQLite() async {
    try {
      // 1. Hive 초기화
      await Hive.initFlutter();

      // 2. Hive Box 열기
      if (!await Hive.boxExists('routines')) {
        return false; // 마이그레이션 불필요
      }

      final hiveBox = await Hive.openBox<dynamic>('routines');

      // 3. SQLite 준비
      final db = await DatabaseHelper().database;

      // 4. 트랜잭션으로 마이그레이션
      await db.transaction((txn) async {
        for (final routine in hiveBox.values) {
          // Hive → SQLite 변환
          await txn.insert('routines', _convertToSQLite(routine));

          // 완료 기록도 마이그레이션
          final history = routine['completionHistory'] as Map?;
          if (history != null) {
            for (final entry in history.entries) {
              await txn.insert('completion_records', {
                'routine_id': routine['id'],
                'date': entry.key,
                'is_completed': entry.value ? 1 : 0,
              });
            }
          }
        }
      });

      // 5. 성공 시 Hive 백업
      await _backupHiveData();

      // 6. Hive 데이터 삭제
      await hiveBox.clear();
      await hiveBox.close();

      return true;
    } catch (e) {
      debugPrint('Migration failed: $e');
      return false;
    }
  }
}
```

---

*다음 단계: 실제 구현 후 worklogs/003.데이터베이스_변경_sqlite.md 작성*